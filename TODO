all in net.minecraft are 3-part-classes, minecraft forge and cpw.mods.fml can be different
load world automatically on start?
all todo to throw exception?

how does intermediary work? how handles 1.7.10 method/event to 1.2.5 block?



no abstract "real" classes!
continue rework!

https://skmedix.github.io/ForgeJavaDocs/javadoc/forge/1.7.10-10.13.4.1614/net/minecraft/world/gen/structure/MapGenVillage.html

Interface methods:
	get_XXX() - returns member variable
	XXXSuper(PARAMS) - calls super.XXX(PARAMS)

for entity mapping where witchery registers its entities into a map, maybe subclass HashMap and hande insertions differently...

--tweakClass org.spongepowered.asm.launch.MixinTweaker --mixin mixins.compatibility.json


Sources:
Eclipse-> Bluild Path-> Add class folder - TEMP_CLASSES
Eclipse project add new source folder (TEMP_CLASSES).
Decompile, put next to .class
start, stop, refresh project explorer
Debug configurations _> Add both to sources and class path


one compatibility layer für alle? Try merge 1.7.10 and 1.10... afterwards, rename .de.dark...sandbox to /compatibility/sandbox/

goblins witchery compatibility (java.lang.reflect.Constructor Mixin)

forge tries create mod objects
-> Mixin append code before return in Contructor.newInstance. When "instanceof Compat_Entity", cast to Compat_Entity and invoke .toReal()
- Code in mod calls Compat_Constructor.newInstance, might need to call getFake or so.

Think again: Why "Mod_Block -> Wrapper_Block -> MC_Block" nicht möglich?



no new Compat_Item allowed!

instanceof abfangen oder doublewrap verhinern...?




All mod classes tagged? When usin @Callback, switch on version (CASE V1_7_10 Call_XX, CASE V1_10_2 Call_YY). in constructor, get and save version.
CompatWrapper_XXX um original Implements CompatI_XXX
factory checks if child, if yes, creates wrapper.
if this.getClass != Compat_XXX.class then is child
HasCallback with MC Versions, to know it is called for version XXX
find all called methods, like overrides

1. merge methods, with CompatWrapper
2. version tagging
3. factory create wrapper if not child
4. big merge
